死锁实验（嵌入式实验第4讲）
==
说明：本文件系邹文杰 14353439(Student ID) 13763361932 zouwj5@mail2.sysu.edu.cn 中山大学数据科学与计算机学院移动信息工程专业学生大学三年级秋季学期《嵌入式导论》课作业报告（Lab4）。
--
&nbsp; &nbsp; 【回答问题1】死锁停在第179次，结果显示如下：

插入0.png

&nbsp; &nbsp; 【原创声明】【原创声明】【原创声明】【原创声明】【原创声明】【原创声明】【原创声明】

&nbsp; &nbsp; 【回答问题2】死锁产生的四个条件：

&nbsp; &nbsp; 1.资源互斥：一个资源每次只能被一个进程申请使用；

&nbsp; &nbsp; 
2.保持资源并且请求资源：一个进程请求资源而被阻塞之时，对已有资源不放弃；

&nbsp; &nbsp; 
3.不剥夺：进程已获得的资源在没有使用完毕之前是不会被强迫释放的；

&nbsp; &nbsp; 
4.相互等待：存在一个不安全序列{a1,a2,...an}满足任意i下，ai等待ai+1所占有的资源，保持资源占有的前提下去申请别的进程所占有的资源；

&nbsp; &nbsp; 
【回答问题3】该程序产生死锁的原因：

&nbsp; &nbsp; 
许多同学对其中的死锁原因没有完全的认识，此处先声明一些预知的信息：

&nbsp; &nbsp; 1.Runnable接口自带一个特殊属性：其run函数将会自成一个线程，拥有获得CPU的资格；

&nbsp; &nbsp; 2.Deadlock中的main函数也自成一个线程，其执行的顺序是：先声明t.start()（该start将会激活run线程），等候若干时间，最终运行a.methodA(b);

&nbsp; &nbsp; 
3.对于同一个类对象而言，其同步函数（synchronized修饰过的函数）最多可以同时运行一个。

&nbsp; &nbsp; 有了上述认识后，可以介绍该死锁是如何产生的，死锁当且仅当遇到类似于下面的情形下才产生：

&nbsp; &nbsp; **a.** 线程1下，程序从main进入，遇到t.start()，激活了线程2（也就是run），此时已经有两个线程了；

&nbsp; &nbsp; **b.** CPU分配给线程1，线程1运行至while倒计时语句，运行至该循环结束之后；

&nbsp; &nbsp; **c.** 线程1再执行a.methodA(b)这行语句，A成员此时调用了同步函数methodA，但注意：仅仅是进入了该函数罢了，该函数中的任何语句都没有执行，戏剧地，CPU分配给了线程2，保留现场信息等动作发生但不做重点介绍；

&nbsp; &nbsp; **d.** CPU执行run函数，进而执行run函数中的b.methodB(a)语句，b请求调用a的last同步函数，但发现存在一个线程正在悬挂（正在等候执行）着a对象的另一个同步函数（methodA），所以b对象调用a的last同步函数这一步被搁置，根据吝啬的CPU不空等原则，CPU分配给线程1；

&nbsp; &nbsp; **e.** CPU分配给线程1，线程1继续执行，它企图执行b.last，此时发现已经存在一个线程正在悬挂着b对象的另一个同步函数，所以线程1被动等候，根据吝啬的CPU不空等原则，CPU资源剥夺，分配给线程2；

&nbsp; &nbsp; **f.** 重复d和e的过程，陷入死锁。

&nbsp; &nbsp; 【原创声明】【原创声明】【原创声明】【原创声明】【原创声明】【原创声明】【原创声明】

&nbsp; &nbsp; ——邹文杰 14353439 13763361932 zouwj5@mail2.sysu.edu.cn 2016-10-18